# 因果关系

同一请求 (intra-request) 的计算任务之间可能存在因果关系，如：

* 进程 P1 通过 HTTP 或 RPC 调用进程 P2
* 进程 P1 写入数据到存储服务中，或从存储服务中读取数据
* 进程 P1 生产消息到 MQ 中，进程 P2 消费到消息并处理
* ...

不同请求 (inter-request) 的计算任务之间也可能存在因果关系，如：

* 请求 R1 和 R2 同时获取某分布式锁，R1 成功，R2 失败
* 请求 R1 写入数据到本地缓存后请求 R2 也写入数据，同时触发批处理
* 请求 R1 写入数据到存储系统后请求 R2 读出对应数据进行处理
* ...

在实践中，开发者习惯以单个请求的视角分析问题，因此调用链追踪系统通常不会关注不同请求之间的因果关系，但会在数据模型上保持对应的表达能力。对于同一请求的计算任务之间的因果关系，通常 SDK 提供方会尽可能地帮助开发者在所有跨进程的连接点上埋点，以此达到追踪目的，如 HTTP/RPC 调用、数据库访问、消息生产和消费等。但有时候源自于 A 请求的计算任务会被 B 请求触发，如下图中的例子所示：

![submitter-and-trigger](./submitter-and-trigger.png)

Request one 将数据 d1 提交到局部写回缓存 (write-back cache)，Request two 将数据 d2 提交到同一个缓存中，触发 d1 被写出到持久化存储中。这时如何归属 d1 的写出操作就决定了调用链追踪系统是选择提交者角度 (submitter-preserving) 还是触发者角度 (trigger-preserving。

## 提交者角度

提交者角度意味着，当聚合或批处理操作被另一个请求触发时，该操作将被归属于提交者。如上方左图所示：Request one 留存在写回缓存中的数据因为 Request two 写入数据而最终被清出，此时清出数据的操作归属于 Request one。

## 触发者角度

触发者角度意味着，当聚合或批处理操作被另一个请求触发时，该操作将被归属于触发者。如上方右图所示：Request one 留存在写回缓存中的数据因为 Request two 写入数据而最终被清出，此时清出数据的操作归属于 Request two。
